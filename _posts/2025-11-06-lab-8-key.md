---
layout: post
title:  "Lab: Working with MODS in XML"
date:   2025-11-06
assigned: 2025-10-31
due: 2025-11-06
categories: activities mods xml xpath python keys
canvas-link: https://umich.instructure.com/courses/779862/assignments/2877258
published: false
---

Below find sample responses to the questions for [Lab 8 on MODS in XML]({% link _posts/2025-10-31-lab-8-xml-mods.md %}).

## Lab Questions & Suggested Responses

### Q1. Are things working?

To make sure things are working, adapt the code from class that we used to count the individual MODS records in the file. How many are there?

_For this task, use a loop with the `.iter()` function to look through all of the elements. In the 25 MODS collection, you will find **1,358** elements in the tree. Also note use of the `.XMLParser()` function, which will improve formatting for written file in Q5._

**Sample code:**

```python
# Sample import statement that runs lxml,
# but if lxml isn't available will load 
# the built-in ElementTree library for XML parsing
try:
    from lxml import etree
    print("running with lxml.etree")
except ImportError:
    import xml.etree.ElementTree as etree
    print("running with Python's xml.etree.ElementTree")
from pathlib import Path

MODS_collection_25 = Path('..','data','xml','2018_lcwa_MODS_25.xml')

# using the `.XMLParser()` function to remove spaces to improve printing later on
# NOTE: only works if spaces are not significant in the XML input
parser = etree.XMLParser(remove_blank_text=True)

metadata = etree.parse(MODS_collection_25, parser=parser).getroot()

el_count = 0 

for element in metadata.iter():
    el_count += 1
    # uncomment the next line to print display
    #print(element.tag)

print(el_count)
```

### Q2. Look for `subject` tags

These records contain `<subject>` elements, but only some of these correspond to headings that are authorized headings in the Library of Congress Subject Headings. Those are marked with the attribute `authority='lcsh'`, embedded in the element. Loop through `<subject>` tags, identify only the ones that include an LCSH attribute (use an XPath expression), then print the content of those subject headings.

**Sample code:**

```python
# define dictionary nsmap as namespace map with mods
nsmap = {
    'mods' : 'http://www.loc.gov/mods/v3',
    'ead3'  : 'http://ead3.archivists.org/schema/',
}

count = 0

for subject in metadata.findall('.//mods:subject[@authority="lcsh"]', nsmap):
    count += 1
    print(subject.tag, subject.attrib)
    # display the element
    print(etree.tostring(subject).decode())

print('Subject tags:',count)
```

Should find 35 subject elements.

**Example subject element (note nested structure):**

```xml
<subject xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" authority="lcsh">
    <topic>Animals</topic>
    <genre>Pictorial works</genre>
</subject>
```

### Q3. Data validation

Check the local call number references to ensure that they are in the proper format (e.g., `lcwaAddddddd` or `lcwaEddddddd`). Try adapting the [regular expression implementation illustrated in the sample MODS notebook under activities 6 & 7](https://github.com/morskyjezek/si676-2025-data/blob/main/examples/xml-working-with-MODS.ipynb). **Hint:** this is similar to what is demonstrated there, but you will need to modify the regex. Look carefully at the identifiers because some will be similar but won't match the expression we built in class. Question: how many correctly formatted identifiers for the LC web archives are there?

**Sample code:**

```python
# import regular expressions library
import re

# the following code assumes the MODS records have been parsed & assigned to "metadata"
# the following code assumes you have established a dictionary called "nsmap" for namespaces, including "mods"

# set up regex pattern to identify the call number:
call_num_pattern = re.compile(r'lcwa[NE]\d{7}')

# a counter for lc IDs
lc_ids = 0

for identifier in metadata.findall('.//mods:mods/mods:identifier', nsmap): 
    if re.match(call_num_pattern, identifier.text):
        lc_ids += 1
        print(identifier.text, identifier.attrib)
    else:
        print(f'not an LC number: { identifier.text }, {identifier.attrib}')

print(f'Found {str(lc_ids)} correctly formatted LC identifiers')
```

**Answer: there are 25 correctly formatted LC web archives identifiers.**

### Q4. Data addition or modification

This step builds on the previous validation question. Once you identify the local call numbers, then ensure they are properly formatted (validation), add a `type` attribute to indicate their source authority. Consult the [LC MODS documentation for `identifier` to see the usage instructions and valid attributes](https://www.loc.gov/standards/mods/userguide/identifier.html#type).

**Sample code (includes print statements to demonstrate changes):**

```python
# import regular expressions library
import re

# the following code assumes the MODS records have been parsed & assigned to "metadata"
# the following code assumes you have established a dictionary called "nsmap" for namespaces, including "mods"

# set up regex pattern to identify the call number:
call_num_pattern = re.compile(r'lcwa[NE]\d{7}')

for identifier in metadata.findall('.//mods:mods/mods:identifier', nsmap): 
    if re.match(call_num_pattern, identifier.text):
        print('LC identifier identified:',identifier.text)
        print(f'ID element and attribs before change:\n\t{identifier.text} {identifier.attrib}\n')
        # when you run the above, note that these identifiers do not have attributes. A valid identifier should have a type, so add "type" as "lcwa" - see https://www.loc.gov/standards/mods/userguide/identifier.html#type
        # set a "type" attribute to note this is an LC web archives identifier aka "lcwa"
        identifier.set('type','lcwa')
        print(f'ID element with attribs after change:\n\t{identifier.text} {identifier.attrib}\n')
        print('full XML element after validation and attribute addition:\n',etree.tostring(identifier).decode(),'\n\n')
```

### Q5. Write a new file

Save the records that you updated in the previous question to a new file, which is valid XML (well-formed, has namespace declaration, and appropriate qualifiers for MODS and any other schemas used in the output).

```python
# the following code assumes:
#     lxml or ET is running as etree
#     25 MODS records have been parsed & assigned to "metadata"
#     you have established a dictionary called "nsmap" for namespaces, including "mods"
#     you have made the modifications to identifiers in Qs 3, 4, and 5

updated_file = Path('..','data','xml','lcwa_MODS_25_updated.xml')

# assign the updated metadata to an ElementTree (full XML doc)
tree = etree.ElementTree(metadata)

tree.write(updated_file, xml_declaration=True, encoding='utf-8', method='xml', pretty_print=True, strip_text=True)
```

## Resources

- [Sample code in a Jupyter notebook][sample-solutions]
- [Intro to Basic XML Usage in Python (Jupyter notebook from course GitHub)][basics-notebook]

[sample-solutions]: TBD
[basics-notebook]: https://github.com/morskyjezek/si676-2025-data/blob/main/examples/xml-intro-basic-functions-ET.ipynb
